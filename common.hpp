#pragma once
#ifdef _KERNEL_MODE
#include <ntifs.h>
#endif

#define KYADRV_USER_DEVICE_PATH L"\\\\.\\KyaDrv"

#ifndef IOCTL_KYADRV_MAP_DRIVER
#define IOCTL_KYADRV_MAP_DRIVER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#ifndef IOCTL_KYADRV_CLEAN_TRACES
#define IOCTL_KYADRV_CLEAN_TRACES CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#ifndef IOCTL_KYADRV_CLEAR_MM_UNLOADED
#define IOCTL_KYADRV_CLEAR_MM_UNLOADED CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif


#define KYADRV_MAX_DRIVER_NAME 260
#define KYADRV_MAP_FLAG_FREE_AFTER_ENTRY 0x1
#define KYADRV_MAP_FLAG_PASS_BASE_AS_PARAM1 0x2

typedef struct _KYADRV_MAP_REQUEST
{
    ULONG ImageSize;
    ULONG Flags;
    ULONGLONG Param1;
    ULONGLONG Param2;
    WCHAR DriverName[KYADRV_MAX_DRIVER_NAME];
    UCHAR Image[1];
} KYADRV_MAP_REQUEST, *PKYADRV_MAP_REQUEST;

typedef struct _KYADRV_MAP_RESULT
{
    ULONGLONG ImageBase;
    ULONGLONG ImageSize;
    NTSTATUS EntryStatus;
} KYADRV_MAP_RESULT, *PKYADRV_MAP_RESULT;

typedef struct _KYADRV_CLEAN_REQUEST
{
    WCHAR VulnerableDriver[KYADRV_MAX_DRIVER_NAME];
    WCHAR CheatDriver[KYADRV_MAX_DRIVER_NAME];
} KYADRV_CLEAN_REQUEST, *PKYADRV_CLEAN_REQUEST;

typedef struct _KYADRV_CLEAR_MM_REQUEST
{
    HANDLE TargetProcessId;
} KYADRV_CLEAR_MM_REQUEST, * PKYADRV_CLEAR_MM_REQUEST;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemExtendedHandleInformation = 64
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    PVOID Object;
    HANDLE UniqueProcessId;
    HANDLE HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

